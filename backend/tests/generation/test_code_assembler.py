"""
Tests for Code Assembler

Tests code assembly, formatting, and file generation.
Updated for simplified LLM-first code assembler.
"""

import pytest

from src.generation.code_assembler import CodeAssembler
from src.generation.types import CodeParts


class TestCodeAssembler:
    """Test suite for CodeAssembler."""
    
    @pytest.fixture
    def assembler(self):
        """Create code assembler instance."""
        return CodeAssembler()
    
    @pytest.fixture
    def sample_code_parts(self):
        """Sample code parts for assembly - complete LLM-generated code."""
        return CodeParts(
            provenance_header="/* Generated by ComponentForge */",
            component_code="""import * as React from "react"
import { cn } from "@/lib/utils"

interface ButtonProps {
  variant?: string;
}

const Button = ({ variant }: ButtonProps) => <button>{variant}</button>

export { Button }""",
            storybook_stories="""import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  component: Button,
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Default: Story = { args: {} };""",
            component_name="Button"
        )
    
    @pytest.fixture
    def legacy_code_parts(self):
        """Sample code parts with separate imports (legacy support)."""
        return CodeParts(
            provenance_header="/* Generated by ComponentForge */",
            imports=[
                'import * as React from "react"',
                'import { cn } from "@/lib/utils"'
            ],
            component_code="""interface ButtonProps {
  variant?: string;
}

const Button = ({ variant }: ButtonProps) => <button>{variant}</button>

export { Button }""",
            storybook_stories='export const Default = { args: {} }',
            component_name="Button"
        )
    
    def test_assembler_initialization(self, assembler):
        """Test that assembler initializes correctly."""
        assert assembler is not None
        # format_script may or may not exist depending on setup
    
    @pytest.mark.asyncio
    async def test_assemble_code_parts(self, assembler, sample_code_parts):
        """Test assembling complete LLM-generated code."""
        result = await assembler.assemble(sample_code_parts)
        
        assert "component" in result
        assert "stories" in result
        assert "files" in result
        
        # Should have component and stories files
        assert "Button.tsx" in result["files"]
        assert "Button.stories.tsx" in result["files"]
        
        # Should NOT have CSS tokens file (removed in simplification)
        assert "Button.tokens.css" not in result["files"]
    
    @pytest.mark.asyncio
    async def test_component_structure(self, assembler, sample_code_parts):
        """Test that finalized component has correct structure."""
        result = await assembler.assemble(sample_code_parts)
        
        component_code = result["component"]
        
        # Should contain provenance header
        assert "Generated by ComponentForge" in component_code
        
        # Should contain imports (from complete code)
        assert "import" in component_code
        
        # Should contain interface
        assert "ButtonProps" in component_code
        
        # Should contain component code
        assert "Button" in component_code
    
    @pytest.mark.asyncio
    async def test_legacy_parts_with_separate_imports(self, assembler, legacy_code_parts):
        """Test backward compatibility with separate imports."""
        result = await assembler.assemble(legacy_code_parts)
        
        component_code = result["component"]
        
        # Should contain imports resolved from separate list
        assert "import" in component_code
        assert "React" in component_code or "react" in component_code
        
        # Should contain component code
        assert "Button" in component_code
    
    @pytest.mark.asyncio
    async def test_css_variables_removed(self, assembler, sample_code_parts):
        """Test that CSS variables are no longer in separate file."""
        result = await assembler.assemble(sample_code_parts)
        
        # CSS variables should NOT be in separate .tokens.css file
        assert "Button.tokens.css" not in result["files"]
    
    @pytest.mark.asyncio
    async def test_stories_generation(self, assembler, sample_code_parts):
        """Test that stories are generated correctly."""
        result = await assembler.assemble(sample_code_parts)
        
        stories_code = result["stories"]
        
        assert len(stories_code) > 0
        assert "Default" in stories_code
    
    @pytest.mark.asyncio
    async def test_format_code_graceful_failure(self, assembler):
        """Test that formatting failures are handled gracefully."""
        # Test with simple code
        code = "const x = 1"
        
        # Should not raise exception even if Prettier is not available
        formatted = await assembler._format_code(code)
        
        # Should return some code (either formatted or original)
        assert formatted is not None
        assert len(formatted) > 0
    
    def test_validate_typescript_placeholder(self, assembler):
        """Test TypeScript validation placeholder."""
        result = assembler.validate_typescript("const x: string = 'test'")
        
        assert result["success"] is True
        assert "errors" in result
        assert "warnings" in result
    
    def test_measure_code_metrics(self, assembler):
        """Test code metrics measurement."""
        code = """import React from 'react'
import { cn } from '@/lib/utils'

interface Props {
  variant: string
}

const Button = ({ variant }: Props) => {
  return <button>{variant}</button>
}

export default Button
"""
        
        metrics = assembler.measure_code_metrics(code)
        
        assert "total_lines" in metrics
        assert "code_lines" in metrics
        assert "import_count" in metrics
        assert "function_count" in metrics
        
        # Should have counted imports
        assert metrics["import_count"] >= 2
        
        # Should have positive line counts
        assert metrics["total_lines"] > 0
        assert metrics["code_lines"] > 0
    
    @pytest.mark.asyncio
    async def test_empty_parts_handling(self, assembler):
        """Test handling of empty code parts."""
        empty_parts = CodeParts(
            provenance_header="",
            component_code="",
            storybook_stories="",
            component_name="Empty"
        )
        
        result = await assembler.assemble(empty_parts)
        
        # Should still return valid structure
        assert "component" in result
        assert "stories" in result
        assert "files" in result
        
        # Should have at least the component file
        assert "Empty.tsx" in result["files"]
